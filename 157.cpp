/*
    Immediately one may notice that (a, b) will repeat across different values
    of n. For example,

        1 / 1 + 1 / 1 = 20 / 10 = 200 / 100 = 2000 / 1000 = ...

    It turns out that each contributes as a distinct solution and we need
    solutions in (a, b, p, n).

    Firstly, we manipulate the given equation to get

        1 / a + 1 / b = p / 10^n
        1 / a = (pb - 10^n) / (10^n * b)        1/b = (pa - 10^n) / (10^n * a)
        (pb - 10^n)a = 10^n * b                 (pb - 10^n)b = 10^n * a

    Multiplying both together, we have

        (pb - 10^n)(pb - 10^n)ab = 10^{2n} * ab
        (pb - 10^n)(pb - 10^n) = 10^{2n}

    Let pb - 10^n = x and pb - 10^n = y so that x <= y and xy = 10^{2n}. In
    principle since n <= 9, then 10^{2n} <= 10^18 = (2^18)(5^18) so the number
    of (x, y) pairs is at most 19 * 19 = 361.

    Next,

        pa = 10^n + x   pb = 10^n + y
        pa / pb = (10^n + x) / (10^n + y)
        a / b = (10^n + x) / (10^n + y)

    For each pair of (x, y), let d = GCD(10^n + x, 10^n + y). Then indeed we
    have solutions (a, b, p, n) can be generated by a positive integer k:

        (a, b, p, n) = ((k / d)(10^n + x), (k / d)(10^n + y), d / k, n)

    We need k | d for p to be a positive integer. Notice that we only need to
    search up to k^2 <= d, because for every k^2 <= d we have two solutions, one
    characterized by k and the other by d / k >= k.

    We collect solutions in (a, b, p, n) across (x, y) across n in an std::set
    to remove any duplicates. Probably the only time this happens is when k * k =
    d, for which both k, d / k characterizes the same solution.
*/

#include <iostream>
#include <utility>
#include <vector>
#include <set>
#include <cstdint>
#include "gmp_util.h"
#include "number_util.h"
#include "prime_util.h"

std::vector<int64_t> primes = { 2 };

std::vector<std::pair<int64_t, int64_t>> get_factors(int n)
{
    std::vector<std::pair<int64_t, int64_t>> pairs;

    // std::pow returns a double with mantissa 53 bits effective which I don't
    // think has enough precision for 10^{2n} <= 10^{18}.
    uint64_t p = util::pow(int64_t(10), 2 * n);

    for (uint64_t e2 = 0, p2 = 1; e2 <= 2 * n; e2++, p2 *= 2)
        for (uint64_t e5 = 0, p5 = 1; p2 * p5 <= p / (p2 * p5); e5++, p5 *= 5)
            pairs.emplace_back(p2 * p5, p / (p2 * p5));

    return pairs;
}

void get_solutions(int n, std::set<std::vector<int64_t>> &solutions)
{
    for (std::pair<int64_t, int64_t> &factor : get_factors(n))
    {
        uint64_t f = util::pow(int64_t(10), n) + factor.first;
        uint64_t g = util::pow(int64_t(10), n) + factor.second;
        uint64_t d = util::gcd(f, g);
        uint64_t step_a = f / d, step_b = g / d;

        uint64_t k = 0;
        while ((++k) * k <= d)
        {
            if (d % k == 0)
            {
                solutions.emplace(std::vector<int64_t>{ k * step_a, k * step_b, d / k, int64_t(n) });
                solutions.emplace(std::vector<int64_t>{ (d / k) * step_a, (d / k) * step_b, k, int64_t(n) });
            }
        }
    }
}

int main()
{
    std::set<std::vector<int64_t>> solutions;

    for (int n = 1; n <= 9; n++)
        get_solutions(n, solutions);

    std::cout << solutions.size();
}
